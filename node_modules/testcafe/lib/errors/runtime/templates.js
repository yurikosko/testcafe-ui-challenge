"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const error_hints_1 = __importDefault(require("../../browser/connection/error-hints"));
const DOCUMENTATION_LINKS = {
    TEST_SOURCE_PARAMETER: 'https://devexpress.github.io/testcafe/documentation/using-testcafe/command-line-interface.html#file-pathglob-pattern',
    FILTER_SETTINGS: 'https://devexpress.github.io/testcafe/documentation/using-testcafe/configuration-file.html#filter'
};
exports.default = {
    [types_1.RUNTIME_ERRORS.cannotCreateMultipleLiveModeRunners]: 'Cannot create multiple live mode runners.',
    [types_1.RUNTIME_ERRORS.cannotRunLiveModeRunnerMultipleTimes]: 'Cannot run a live mode runner multiple times.',
    [types_1.RUNTIME_ERRORS.browserDisconnected]: 'The {userAgent} browser disconnected. This problem may appear when a browser hangs or is closed, or due to network issues.',
    [types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers]: 'The following browsers disconnected: {userAgents}. Tests will not be run.',
    [types_1.RUNTIME_ERRORS.testRunRequestInDisconnectedBrowser]: '"{browser}" has disconnected during test execution',
    [types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection]: 'Unable to establish one or more of the specified browser connections.',
    [types_1.RUNTIME_ERRORS.cannotFindBrowser]: 'Unable to find the browser. "{browser}" is not a browser alias or path to an executable file.',
    [types_1.RUNTIME_ERRORS.browserProviderNotFound]: 'The specified "{providerName}" browser provider was not found.',
    [types_1.RUNTIME_ERRORS.browserNotSet]: 'No browser selected to test against.',
    [types_1.RUNTIME_ERRORS.testFilesNotFound]: 'TestCafe could not find the test files that match the following patterns:\n' +
        '{sourceList}\n\n' +
        'The "{cwd}" current working directory was used as the base path.\n' +
        'Ensure the file patterns are correct or change the current working directory.\n' +
        `For more information on how to specify test files, see ${DOCUMENTATION_LINKS.TEST_SOURCE_PARAMETER}.`,
    [types_1.RUNTIME_ERRORS.noTestsToRun]: 'No tests found in the specified source files.\n' +
        "Ensure the sources contain the 'fixture' and 'test' directives.",
    [types_1.RUNTIME_ERRORS.noTestsToRunDueFiltering]: 'The specified filter settings exclude all tests.\n' +
        'Modify these settings to leave at least one available test.\n' +
        `For more information on how to specify filter settings, see ${DOCUMENTATION_LINKS.FILTER_SETTINGS}.`,
    [types_1.RUNTIME_ERRORS.cannotFindReporterForAlias]: 'The provided "{name}" reporter does not exist. Check that you have specified the report format correctly.',
    [types_1.RUNTIME_ERRORS.multipleSameStreamReporters]: 'The following reporters attempted to write to the same output stream: "{reporters}". Only one reporter can write to a stream.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidRegExp]: 'The "{optionName}" option value is not a valid regular expression.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue]: 'The "{optionName}" option value is not a valid key-value pair.',
    [types_1.RUNTIME_ERRORS.invalidSpeedValue]: 'Speed should be a number between 0.01 and 1.',
    [types_1.RUNTIME_ERRORS.invalidConcurrencyFactor]: 'The concurrency factor should be an integer greater or equal to 1.',
    [types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency]: 'The number of remote browsers should be divisible by the factor of concurrency.',
    [types_1.RUNTIME_ERRORS.portsOptionRequiresTwoNumbers]: 'The "--ports" option requires two numbers to be specified.',
    [types_1.RUNTIME_ERRORS.portIsNotFree]: 'The specified {portNum} port is already in use by another program.',
    [types_1.RUNTIME_ERRORS.invalidHostname]: 'The specified "{hostname}" hostname cannot be resolved to the current machine.',
    [types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource]: 'Cannot find a test source file at "{path}".',
    [types_1.RUNTIME_ERRORS.clientFunctionCodeIsNotAFunction]: '{#instantiationCallsiteName} code is expected to be specified as a function, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.selectorInitializedWithWrongType]: '{#instantiationCallsiteName} is expected to be initialized with a function, CSS selector string, another Selector, node snapshot or a Promise returned by a Selector, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun]: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
    [types_1.RUNTIME_ERRORS.regeneratorInClientFunctionCode]: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
    [types_1.RUNTIME_ERRORS.invalidClientFunctionTestRunBinding]: 'The "boundTestRun" option value is expected to be a test controller.',
    [types_1.RUNTIME_ERRORS.invalidValueType]: '{smthg} is expected to be a {type}, but it was {actual}.',
    [types_1.RUNTIME_ERRORS.unsupportedUrlProtocol]: 'The specified "{url}" test page URL uses an unsupported {protocol}:// protocol. Only relative URLs or absolute URLs with http://, https:// and file:// protocols are supported.',
    [types_1.RUNTIME_ERRORS.testControllerProxyCannotResolveTestRun]: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
    [types_1.RUNTIME_ERRORS.timeLimitedPromiseTimeoutExpired]: 'Timeout expired for a time limited promise',
    [types_1.RUNTIME_ERRORS.cannotSetVideoOptionsWithoutBaseVideoPathSpecified]: 'Unable to set video or encoding options when video recording is disabled. Specify the base path where video files are stored to enable recording.',
    [types_1.RUNTIME_ERRORS.multipleAPIMethodCallForbidden]: 'You cannot call the "{methodName}" method more than once. Pass an array of parameters to this method instead.',
    [types_1.RUNTIME_ERRORS.invalidReporterOutput]: "Specify a file name or a writable stream as the reporter's output target.",
    [types_1.RUNTIME_ERRORS.cannotReadSSLCertFile]: 'Unable to read the "{path}" file, specified by the "{option}" ssl option. Error details:\n' +
        '\n' +
        '{err}',
    [types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError]: 'Cannot prepare tests due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.cannotParseRawFile]: 'Cannot parse a test source file in the raw format at "{path}" due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.testedAppFailedWithError]: 'Tested app failed with an error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.unableToOpenBrowser]: 'Was unable to open the browser "{alias}" due to error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.requestHookConfigureAPIError]: 'There was an error while configuring the request hook:\n' +
        '\n' +
        '{requestHookName}: {errMsg}',
    [types_1.RUNTIME_ERRORS.forbiddenCharatersInScreenshotPath]: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n' +
        ' {forbiddenCharsDescription}',
    [types_1.RUNTIME_ERRORS.cannotFindFFMPEG]: 'Unable to locate the FFmpeg executable required to record videos. Do one of the following:\n' +
        '\n' +
        '* add the FFmpeg installation directory to the PATH environment variable,\n' +
        '* specify the path to the FFmpeg executable in the FFMPEG_PATH environment variable or the ffmpegPath video option,\n' +
        '* install the @ffmpeg-installer/ffmpeg package from npm.',
    [types_1.RUNTIME_ERRORS.cannotFindTypescriptConfigurationFile]: 'Unable to find the TypeScript configuration file in "{filePath}"',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerIsNotSpecified]: 'Specify the JavaScript file path, module name or script content to inject a client script.',
    [types_1.RUNTIME_ERRORS.clientScriptBasePathIsNotSpecified]: 'Specify the base path for the client script file.',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerMultipleContentSources]: 'You cannot combine the file path, module name and script content when you specify a client script to inject.',
    [types_1.RUNTIME_ERRORS.cannotLoadClientScriptFromPath]: 'Cannot load a client script from {path}.',
    [types_1.RUNTIME_ERRORS.clientScriptModuleEntryPointPathCalculationError]: 'An error occurred when trying to locate the injected client script module:\n\n{errorMessage}.',
    [types_1.RUNTIME_ERRORS.methodIsNotAvailableForAnIPCHost]: 'This method cannot be called on a service host.',
    [types_1.RUNTIME_ERRORS.tooLargeIPCPayload]: 'The specified payload is too large to form an IPC packet.',
    [types_1.RUNTIME_ERRORS.malformedIPCMessage]: 'Cannot process a malformed IPC message.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCHeadPacket]: 'Cannot create an IPC message due to an unexpected IPC head packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCBodyPacket]: 'Cannot create an IPC message due to an unexpected IPC body packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCTailPacket]: 'Cannot create an IPC message due to an unexpected IPC tail packet.',
    [types_1.RUNTIME_ERRORS.cannotRunLocalNonHeadlessBrowserWithoutDisplay]: 'Your Linux version does not have a graphic subsystem to run {browserAlias} with a GUI. ' +
        'You can launch the browser in headless mode. ' +
        'If you use a portable browser version, ' +
        'specify the browser alias before the path instead of the \'path\' prefix. ' +
        'For more information, see https://devexpress.github.io/testcafe/documentation/guides/concepts/browsers.html#test-in-headless-mode',
    [types_1.RUNTIME_ERRORS.uncaughtErrorInReporter]: 'An uncaught error occurred in the "{reporterName}" reporter\'s "{methodName}" method. Error details:\n{originalError}',
    [types_1.RUNTIME_ERRORS.roleInitializedWithRelativeUrl]: 'You cannot specify relative login page URLs in the Role constructor. Use an absolute URL.',
    [types_1.RUNTIME_ERRORS.typeScriptCompilerLoadingError]: 'Unable to load the TypeScript compiler.\n{originErrorMessage}.',
    [types_1.RUNTIME_ERRORS.cannotCustomizeSpecifiedCompilers]: 'You cannot specify options for the {noncustomizableCompilerList} compiler{suffix}.',
    [types_1.RUNTIME_ERRORS.cannotEnableRetryTestPagesOption]: 'Cannot enable the \'retryTestPages\' option. Apply one of the following two solutions:\n' +
        '-- set \'localhost\' as the value of the \'hostname\' option\n' +
        '-- run TestCafe over HTTPS\n',
    [types_1.RUNTIME_ERRORS.browserConnectionError]: '{originErrorMessage}\n{numOfNotOpenedConnection} of {numOfAllConnections} browser connections have not been established:\n{listOfNotOpenedConnections}\n\nHints:\n{listOfHints}',
    [error_hints_1.default.TooHighConcurrencyFactor]: 'The error can be due to a concurrency factor that is too high for the host machine’s performance (the factor value {concurrencyFactor} was specified). ' +
        'Try to decrease the concurrency factor or ensure more system resources are available on the host machine.',
    [error_hints_1.default.UseBrowserInitOption]: 'Use the "browserInitTimeout" option to allow more time for the browser to start. The timeout is set to {browserInitTimeoutMsg}.',
    [error_hints_1.default.RestErrorCauses]: 'The error can also be caused by network issues or remote device failure. Make sure that the connection is stable and the remote device can be reached.'
};
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3RlbXBsYXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSwrQ0FBK0M7QUFDL0MsZ0VBQWdFOzs7OztBQUVoRSxvQ0FBMEM7QUFDMUMsdUZBQThFO0FBRTlFLE1BQU0sbUJBQW1CLEdBQUc7SUFDeEIscUJBQXFCLEVBQUUsc0hBQXNIO0lBQzdJLGVBQWUsRUFBUSxtR0FBbUc7Q0FDN0gsQ0FBQztBQUVGLGtCQUFlO0lBQ1gsQ0FBQyxzQkFBYyxDQUFDLG1DQUFtQyxDQUFDLEVBQUcsMkNBQTJDO0lBQ2xHLENBQUMsc0JBQWMsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUFFLCtDQUErQztJQUN0RyxDQUFDLHNCQUFjLENBQUMsbUJBQW1CLENBQUMsRUFBbUIsNEhBQTRIO0lBQ25MLENBQUMsc0JBQWMsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUFFLDJFQUEyRTtJQUNsSSxDQUFDLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsRUFBRyxvREFBb0Q7SUFDM0csQ0FBQyxzQkFBYyxDQUFDLGdDQUFnQyxDQUFDLEVBQU0sdUVBQXVFO0lBQzlILENBQUMsc0JBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFxQiwrRkFBK0Y7SUFDdEosQ0FBQyxzQkFBYyxDQUFDLHVCQUF1QixDQUFDLEVBQWUsZ0VBQWdFO0lBQ3ZILENBQUMsc0JBQWMsQ0FBQyxhQUFhLENBQUMsRUFBeUIsc0NBQXNDO0lBRTdGLENBQUMsc0JBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLDZFQUE2RTtRQUM3RSxrQkFBa0I7UUFDbEIsb0VBQW9FO1FBQ3BFLGlGQUFpRjtRQUNqRiwwREFBMEQsbUJBQW1CLENBQUMscUJBQXFCLEdBQUc7SUFFMUksQ0FBQyxzQkFBYyxDQUFDLFlBQVksQ0FBQyxFQUFFLGlEQUFpRDtRQUNqRCxpRUFBaUU7SUFF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QUEwQixDQUFDLHdCQUF3QixDQUFDLEVBQUUseUpBQXlKO1FBQ3pKLDJHQUEyRztJQUNsSyxDQUFDLHFCQUEwQixDQUFDLG9CQUFvQixDQUFDLEVBQUUsaUlBQWlJO0lBQ3BMLENBQUMscUJBQTBCLENBQUMsZUFBZSxDQUFDLEVBQU8sd0pBQXdKO0NBQzlNLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXQVJOSU5HOiB0aGlzIGZpbGUgaXMgdXNlZCBieSBib3RoIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIuXG4vLyBEbyBub3QgdXNlIGFueSBicm93c2VyIG9yIG5vZGUtc3BlY2lmaWMgQVBJIVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBCcm93c2VyQ29ubmVjdGlvbkVycm9ySGludCBmcm9tICcuLi8uLi9icm93c2VyL2Nvbm5lY3Rpb24vZXJyb3ItaGludHMnO1xuXG5jb25zdCBET0NVTUVOVEFUSU9OX0xJTktTID0ge1xuICAgIFRFU1RfU09VUkNFX1BBUkFNRVRFUjogJ2h0dHBzOi8vZGV2ZXhwcmVzcy5naXRodWIuaW8vdGVzdGNhZmUvZG9jdW1lbnRhdGlvbi91c2luZy10ZXN0Y2FmZS9jb21tYW5kLWxpbmUtaW50ZXJmYWNlLmh0bWwjZmlsZS1wYXRoZ2xvYi1wYXR0ZXJuJyxcbiAgICBGSUxURVJfU0VUVElOR1M6ICAgICAgICdodHRwczovL2RldmV4cHJlc3MuZ2l0aHViLmlvL3Rlc3RjYWZlL2RvY3VtZW50YXRpb24vdXNpbmctdGVzdGNhZmUvY29uZmlndXJhdGlvbi1maWxlLmh0bWwjZmlsdGVyJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RDcmVhdGVNdWx0aXBsZUxpdmVNb2RlUnVubmVyc106ICAnQ2Fubm90IGNyZWF0ZSBtdWx0aXBsZSBsaXZlIG1vZGUgcnVubmVycy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSdW5MaXZlTW9kZVJ1bm5lck11bHRpcGxlVGltZXNdOiAnQ2Fubm90IHJ1biBhIGxpdmUgbW9kZSBydW5uZXIgbXVsdGlwbGUgdGltZXMuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3NlckRpc2Nvbm5lY3RlZF06ICAgICAgICAgICAgICAgICAgJ1RoZSB7dXNlckFnZW50fSBicm93c2VyIGRpc2Nvbm5lY3RlZC4gVGhpcyBwcm9ibGVtIG1heSBhcHBlYXIgd2hlbiBhIGJyb3dzZXIgaGFuZ3Mgb3IgaXMgY2xvc2VkLCBvciBkdWUgdG8gbmV0d29yayBpc3N1ZXMuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UnVuQWdhaW5zdERpc2Nvbm5lY3RlZEJyb3dzZXJzXTogJ1RoZSBmb2xsb3dpbmcgYnJvd3NlcnMgZGlzY29ubmVjdGVkOiB7dXNlckFnZW50c30uIFRlc3RzIHdpbGwgbm90IGJlIHJ1bi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0UnVuUmVxdWVzdEluRGlzY29ubmVjdGVkQnJvd3Nlcl06ICAnXCJ7YnJvd3Nlcn1cIiBoYXMgZGlzY29ubmVjdGVkIGR1cmluZyB0ZXN0IGV4ZWN1dGlvbicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uXTogICAgICdVbmFibGUgdG8gZXN0YWJsaXNoIG9uZSBvciBtb3JlIG9mIHRoZSBzcGVjaWZpZWQgYnJvd3NlciBjb25uZWN0aW9ucy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kQnJvd3Nlcl06ICAgICAgICAgICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgdGhlIGJyb3dzZXIuIFwie2Jyb3dzZXJ9XCIgaXMgbm90IGEgYnJvd3NlciBhbGlhcyBvciBwYXRoIHRvIGFuIGV4ZWN1dGFibGUgZmlsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5icm93c2VyUHJvdmlkZXJOb3RGb3VuZF06ICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBcIntwcm92aWRlck5hbWV9XCIgYnJvd3NlciBwcm92aWRlciB3YXMgbm90IGZvdW5kLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmJyb3dzZXJOb3RTZXRdOiAgICAgICAgICAgICAgICAgICAgICAgICdObyBicm93c2VyIHNlbGVjdGVkIHRvIHRlc3QgYWdhaW5zdC4nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLnRlc3RGaWxlc05vdEZvdW5kXTogJ1Rlc3RDYWZlIGNvdWxkIG5vdCBmaW5kIHRoZSB0ZXN0IGZpbGVzIHRoYXQgbWF0Y2ggdGhlIGZvbGxvd2luZyBwYXR0ZXJuczpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3NvdXJjZUxpc3R9XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntjd2R9XCIgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSB3YXMgdXNlZCBhcyB0aGUgYmFzZSBwYXRoLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFbnN1cmUgdGhlIGZpbGUgcGF0dGVybnMgYXJlIGNvcnJlY3Qgb3IgY2hhbmdlIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gc3BlY2lmeSB0ZXN0IGZpbGVzLCBzZWUgJHtET0NVTUVOVEFUSU9OX0xJTktTLlRFU1RfU09VUkNFX1BBUkFNRVRFUn0uYCxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5ub1Rlc3RzVG9SdW5dOiAnTm8gdGVzdHMgZm91bmQgaW4gdGhlIHNwZWNpZmllZCBzb3VyY2UgZmlsZXMuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRW5zdXJlIHRoZSBzb3VyY2VzIGNvbnRhaW4gdGhlICdmaXh0dXJlJyBhbmQgJ3Rlc3QnIGRpcmVjdGl2ZXMuXCIsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMubm9UZXN0c1RvUnVuRHVlRmlsdGVyaW5nXTogJ1RoZSBzcGVjaWZpZWQgZmlsdGVyIHNldHRpbmdzIGV4Y2x1ZGUgYWxsIHRlc3RzLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTW9kaWZ5IHRoZXNlIHNldHRpbmdzIHRvIGxlYXZlIGF0IGxlYXN0IG9uZSBhdmFpbGFibGUgdGVzdC5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byBzcGVjaWZ5IGZpbHRlciBzZXR0aW5ncywgc2VlICR7RE9DVU1FTlRBVElPTl9MSU5LUy5GSUxURVJfU0VUVElOR1N9LmAsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFJlcG9ydGVyRm9yQWxpYXNdOiAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3ZpZGVkIFwie25hbWV9XCIgcmVwb3J0ZXIgZG9lcyBub3QgZXhpc3QuIENoZWNrIHRoYXQgeW91IGhhdmUgc3BlY2lmaWVkIHRoZSByZXBvcnQgZm9ybWF0IGNvcnJlY3RseS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5tdWx0aXBsZVNhbWVTdHJlYW1SZXBvcnRlcnNdOiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgZm9sbG93aW5nIHJlcG9ydGVycyBhdHRlbXB0ZWQgdG8gd3JpdGUgdG8gdGhlIHNhbWUgb3V0cHV0IHN0cmVhbTogXCJ7cmVwb3J0ZXJzfVwiLiBPbmx5IG9uZSByZXBvcnRlciBjYW4gd3JpdGUgdG8gYSBzdHJlYW0uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMub3B0aW9uVmFsdWVJc05vdFZhbGlkUmVnRXhwXTogICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie29wdGlvbk5hbWV9XCIgb3B0aW9uIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5vcHRpb25WYWx1ZUlzTm90VmFsaWRLZXlWYWx1ZV06ICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7b3B0aW9uTmFtZX1cIiBvcHRpb24gdmFsdWUgaXMgbm90IGEgdmFsaWQga2V5LXZhbHVlIHBhaXIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFNwZWVkVmFsdWVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU3BlZWQgc2hvdWxkIGJlIGEgbnVtYmVyIGJldHdlZW4gMC4wMSBhbmQgMS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQ29uY3VycmVuY3lGYWN0b3JdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgY29uY3VycmVuY3kgZmFjdG9yIHNob3VsZCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3REaXZpZGVSZW1vdGVzQ291bnRCeUNvbmN1cnJlbmN5XTogICAgICAgICAgICAgICdUaGUgbnVtYmVyIG9mIHJlbW90ZSBicm93c2VycyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IHRoZSBmYWN0b3Igb2YgY29uY3VycmVuY3kuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMucG9ydHNPcHRpb25SZXF1aXJlc1R3b051bWJlcnNdOiAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwiLS1wb3J0c1wiIG9wdGlvbiByZXF1aXJlcyB0d28gbnVtYmVycyB0byBiZSBzcGVjaWZpZWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMucG9ydElzTm90RnJlZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCB7cG9ydE51bX0gcG9ydCBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIHByb2dyYW0uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZEhvc3RuYW1lXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBcIntob3N0bmFtZX1cIiBob3N0bmFtZSBjYW5ub3QgYmUgcmVzb2x2ZWQgdG8gdGhlIGN1cnJlbnQgbWFjaGluZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kU3BlY2lmaWVkVGVzdFNvdXJjZV06ICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgZmluZCBhIHRlc3Qgc291cmNlIGZpbGUgYXQgXCJ7cGF0aH1cIi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRGdW5jdGlvbkNvZGVJc05vdEFGdW5jdGlvbl06ICAgICAgICAgICAgICAgICAgICd7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUgaXMgZXhwZWN0ZWQgdG8gYmUgc3BlY2lmaWVkIGFzIGEgZnVuY3Rpb24sIGJ1dCB7dHlwZX0gd2FzIHBhc3NlZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5zZWxlY3RvckluaXRpYWxpemVkV2l0aFdyb25nVHlwZV06ICAgICAgICAgICAgICAgICAgICd7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGlzIGV4cGVjdGVkIHRvIGJlIGluaXRpYWxpemVkIHdpdGggYSBmdW5jdGlvbiwgQ1NTIHNlbGVjdG9yIHN0cmluZywgYW5vdGhlciBTZWxlY3Rvciwgbm9kZSBzbmFwc2hvdCBvciBhIFByb21pc2UgcmV0dXJuZWQgYnkgYSBTZWxlY3RvciwgYnV0IHt0eXBlfSB3YXMgcGFzc2VkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNsaWVudEZ1bmN0aW9uQ2Fubm90UmVzb2x2ZVRlc3RSdW5dOiAgICAgICAgICAgICAgICAgXCJ7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNhbm5vdCBpbXBsaWNpdGx5IHJlc29sdmUgdGhlIHRlc3QgcnVuIGluIGNvbnRleHQgb2Ygd2hpY2ggaXQgc2hvdWxkIGJlIGV4ZWN1dGVkLiBJZiB5b3UgbmVlZCB0byBjYWxsIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gZnJvbSB0aGUgTm9kZS5qcyBBUEkgY2FsbGJhY2ssIHBhc3MgdGhlIHRlc3QgY29udHJvbGxlciBtYW51YWxseSB2aWEgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSdzIGAud2l0aCh7IGJvdW5kVGVzdFJ1bjogdCB9KWAgbWV0aG9kIGZpcnN0LiBOb3RlIHRoYXQgeW91IGNhbm5vdCBleGVjdXRlIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gb3V0c2lkZSB0aGUgdGVzdCBjb2RlLlwiLFxuICAgIFtSVU5USU1FX0VSUk9SUy5yZWdlbmVyYXRvckluQ2xpZW50RnVuY3Rpb25Db2RlXTogICAgICAgICAgICAgICAgICAgIGB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUsIGFyZ3VtZW50cyBvciBkZXBlbmRlbmNpZXMgY2Fubm90IGNvbnRhaW4gZ2VuZXJhdG9ycyBvciBcImFzeW5jL2F3YWl0XCIgc3ludGF4ICh1c2UgUHJvbWlzZXMgaW5zdGVhZCkuYCxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZENsaWVudEZ1bmN0aW9uVGVzdFJ1bkJpbmRpbmddOiAgICAgICAgICAgICAgICAnVGhlIFwiYm91bmRUZXN0UnVuXCIgb3B0aW9uIHZhbHVlIGlzIGV4cGVjdGVkIHRvIGJlIGEgdGVzdCBjb250cm9sbGVyLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRWYWx1ZVR5cGVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tzbXRoZ30gaXMgZXhwZWN0ZWQgdG8gYmUgYSB7dHlwZX0sIGJ1dCBpdCB3YXMge2FjdHVhbH0uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5zdXBwb3J0ZWRVcmxQcm90b2NvbF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBcInt1cmx9XCIgdGVzdCBwYWdlIFVSTCB1c2VzIGFuIHVuc3VwcG9ydGVkIHtwcm90b2NvbH06Ly8gcHJvdG9jb2wuIE9ubHkgcmVsYXRpdmUgVVJMcyBvciBhYnNvbHV0ZSBVUkxzIHdpdGggaHR0cDovLywgaHR0cHM6Ly8gYW5kIGZpbGU6Ly8gcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudGVzdENvbnRyb2xsZXJQcm94eUNhbm5vdFJlc29sdmVUZXN0UnVuXTogICAgICAgICAgICBgQ2Fubm90IGltcGxpY2l0bHkgcmVzb2x2ZSB0aGUgdGVzdCBydW4gaW4gdGhlIGNvbnRleHQgb2Ygd2hpY2ggdGhlIHRlc3QgY29udHJvbGxlciBhY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkLiBVc2UgdGVzdCBmdW5jdGlvbidzICd0JyBhcmd1bWVudCBpbnN0ZWFkLmAsXG4gICAgW1JVTlRJTUVfRVJST1JTLnRpbWVMaW1pdGVkUHJvbWlzZVRpbWVvdXRFeHBpcmVkXTogICAgICAgICAgICAgICAgICAgJ1RpbWVvdXQgZXhwaXJlZCBmb3IgYSB0aW1lIGxpbWl0ZWQgcHJvbWlzZScsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFNldFZpZGVvT3B0aW9uc1dpdGhvdXRCYXNlVmlkZW9QYXRoU3BlY2lmaWVkXTogJ1VuYWJsZSB0byBzZXQgdmlkZW8gb3IgZW5jb2Rpbmcgb3B0aW9ucyB3aGVuIHZpZGVvIHJlY29yZGluZyBpcyBkaXNhYmxlZC4gU3BlY2lmeSB0aGUgYmFzZSBwYXRoIHdoZXJlIHZpZGVvIGZpbGVzIGFyZSBzdG9yZWQgdG8gZW5hYmxlIHJlY29yZGluZy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5tdWx0aXBsZUFQSU1ldGhvZENhbGxGb3JiaWRkZW5dOiAgICAgICAgICAgICAgICAgICAgICdZb3UgY2Fubm90IGNhbGwgdGhlIFwie21ldGhvZE5hbWV9XCIgbWV0aG9kIG1vcmUgdGhhbiBvbmNlLiBQYXNzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMgdG8gdGhpcyBtZXRob2QgaW5zdGVhZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkUmVwb3J0ZXJPdXRwdXRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3BlY2lmeSBhIGZpbGUgbmFtZSBvciBhIHdyaXRhYmxlIHN0cmVhbSBhcyB0aGUgcmVwb3J0ZXIncyBvdXRwdXQgdGFyZ2V0LlwiLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSZWFkU1NMQ2VydEZpbGVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmFibGUgdG8gcmVhZCB0aGUgXCJ7cGF0aH1cIiBmaWxlLCBzcGVjaWZpZWQgYnkgdGhlIFwie29wdGlvbn1cIiBzc2wgb3B0aW9uLiBFcnJvciBkZXRhaWxzOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vycn0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFByZXBhcmVUZXN0c0R1ZVRvRXJyb3JdOiAnQ2Fubm90IHByZXBhcmUgdGVzdHMgZHVlIHRvIGFuIGVycm9yLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UGFyc2VSYXdGaWxlXTogJ0Nhbm5vdCBwYXJzZSBhIHRlc3Qgc291cmNlIGZpbGUgaW4gdGhlIHJhdyBmb3JtYXQgYXQgXCJ7cGF0aH1cIiBkdWUgdG8gYW4gZXJyb3IuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMudGVzdGVkQXBwRmFpbGVkV2l0aEVycm9yXTogJ1Rlc3RlZCBhcHAgZmFpbGVkIHdpdGggYW4gZXJyb3I6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMudW5hYmxlVG9PcGVuQnJvd3Nlcl06ICdXYXMgdW5hYmxlIHRvIG9wZW4gdGhlIGJyb3dzZXIgXCJ7YWxpYXN9XCIgZHVlIHRvIGVycm9yLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMucmVxdWVzdEhvb2tDb25maWd1cmVBUElFcnJvcl06ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY29uZmlndXJpbmcgdGhlIHJlcXVlc3QgaG9vazpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7cmVxdWVzdEhvb2tOYW1lfToge2Vyck1zZ30nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmZvcmJpZGRlbkNoYXJhdGVyc0luU2NyZWVuc2hvdFBhdGhdOiAnVGhlcmUgYXJlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIGluIHRoZSBcIntzY3JlZW5zaG90UGF0aH1cIiB7c2NyZWVuc2hvdFBhdGhUeXBlfTpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcge2ZvcmJpZGRlbkNoYXJzRGVzY3JpcHRpb259JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kRkZNUEVHXTogJ1VuYWJsZSB0byBsb2NhdGUgdGhlIEZGbXBlZyBleGVjdXRhYmxlIHJlcXVpcmVkIHRvIHJlY29yZCB2aWRlb3MuIERvIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyogYWRkIHRoZSBGRm1wZWcgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeSB0byB0aGUgUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSxcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcqIHNwZWNpZnkgdGhlIHBhdGggdG8gdGhlIEZGbXBlZyBleGVjdXRhYmxlIGluIHRoZSBGRk1QRUdfUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSBvciB0aGUgZmZtcGVnUGF0aCB2aWRlbyBvcHRpb24sXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKiBpbnN0YWxsIHRoZSBAZmZtcGVnLWluc3RhbGxlci9mZm1wZWcgcGFja2FnZSBmcm9tIG5wbS4nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRUeXBlc2NyaXB0Q29uZmlndXJhdGlvbkZpbGVdOiAgICAgICAgICAgICdVbmFibGUgdG8gZmluZCB0aGUgVHlwZVNjcmlwdCBjb25maWd1cmF0aW9uIGZpbGUgaW4gXCJ7ZmlsZVBhdGh9XCInLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRJbml0aWFsaXplcklzTm90U3BlY2lmaWVkXTogICAgICAgICAgICAnU3BlY2lmeSB0aGUgSmF2YVNjcmlwdCBmaWxlIHBhdGgsIG1vZHVsZSBuYW1lIG9yIHNjcmlwdCBjb250ZW50IHRvIGluamVjdCBhIGNsaWVudCBzY3JpcHQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0QmFzZVBhdGhJc05vdFNwZWNpZmllZF06ICAgICAgICAgICAgICAgJ1NwZWNpZnkgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIGNsaWVudCBzY3JpcHQgZmlsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRJbml0aWFsaXplck11bHRpcGxlQ29udGVudFNvdXJjZXNdOiAgICAnWW91IGNhbm5vdCBjb21iaW5lIHRoZSBmaWxlIHBhdGgsIG1vZHVsZSBuYW1lIGFuZCBzY3JpcHQgY29udGVudCB3aGVuIHlvdSBzcGVjaWZ5IGEgY2xpZW50IHNjcmlwdCB0byBpbmplY3QuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90TG9hZENsaWVudFNjcmlwdEZyb21QYXRoXTogICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBsb2FkIGEgY2xpZW50IHNjcmlwdCBmcm9tIHtwYXRofS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRNb2R1bGVFbnRyeVBvaW50UGF0aENhbGN1bGF0aW9uRXJyb3JdOiAnQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiB0cnlpbmcgdG8gbG9jYXRlIHRoZSBpbmplY3RlZCBjbGllbnQgc2NyaXB0IG1vZHVsZTpcXG5cXG57ZXJyb3JNZXNzYWdlfS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5tZXRob2RJc05vdEF2YWlsYWJsZUZvckFuSVBDSG9zdF06ICAgICAgICAgICAgICAgICAnVGhpcyBtZXRob2QgY2Fubm90IGJlIGNhbGxlZCBvbiBhIHNlcnZpY2UgaG9zdC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy50b29MYXJnZUlQQ1BheWxvYWRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBmb3JtIGFuIElQQyBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMubWFsZm9ybWVkSVBDTWVzc2FnZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBwcm9jZXNzIGEgbWFsZm9ybWVkIElQQyBtZXNzYWdlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuZXhwZWN0ZWRJUENIZWFkUGFja2V0XTogICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgY3JlYXRlIGFuIElQQyBtZXNzYWdlIGR1ZSB0byBhbiB1bmV4cGVjdGVkIElQQyBoZWFkIHBhY2tldC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy51bmV4cGVjdGVkSVBDQm9keVBhY2tldF06ICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBhbiBJUEMgbWVzc2FnZSBkdWUgdG8gYW4gdW5leHBlY3RlZCBJUEMgYm9keSBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5leHBlY3RlZElQQ1RhaWxQYWNrZXRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgYW4gSVBDIG1lc3NhZ2UgZHVlIHRvIGFuIHVuZXhwZWN0ZWQgSVBDIHRhaWwgcGFja2V0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFJ1bkxvY2FsTm9uSGVhZGxlc3NCcm93c2VyV2l0aG91dERpc3BsYXldOlxuICAgICAgICAnWW91ciBMaW51eCB2ZXJzaW9uIGRvZXMgbm90IGhhdmUgYSBncmFwaGljIHN1YnN5c3RlbSB0byBydW4ge2Jyb3dzZXJBbGlhc30gd2l0aCBhIEdVSS4gJyArXG4gICAgICAgICdZb3UgY2FuIGxhdW5jaCB0aGUgYnJvd3NlciBpbiBoZWFkbGVzcyBtb2RlLiAnICtcbiAgICAgICAgJ0lmIHlvdSB1c2UgYSBwb3J0YWJsZSBicm93c2VyIHZlcnNpb24sICcgK1xuICAgICAgICAnc3BlY2lmeSB0aGUgYnJvd3NlciBhbGlhcyBiZWZvcmUgdGhlIHBhdGggaW5zdGVhZCBvZiB0aGUgXFwncGF0aFxcJyBwcmVmaXguICcgK1xuICAgICAgICAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL2RldmV4cHJlc3MuZ2l0aHViLmlvL3Rlc3RjYWZlL2RvY3VtZW50YXRpb24vZ3VpZGVzL2NvbmNlcHRzL2Jyb3dzZXJzLmh0bWwjdGVzdC1pbi1oZWFkbGVzcy1tb2RlJyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy51bmNhdWdodEVycm9ySW5SZXBvcnRlcl06ICAgICAgICAgICAnQW4gdW5jYXVnaHQgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIFwie3JlcG9ydGVyTmFtZX1cIiByZXBvcnRlclxcJ3MgXCJ7bWV0aG9kTmFtZX1cIiBtZXRob2QuIEVycm9yIGRldGFpbHM6XFxue29yaWdpbmFsRXJyb3J9JyxcbiAgICBbUlVOVElNRV9FUlJPUlMucm9sZUluaXRpYWxpemVkV2l0aFJlbGF0aXZlVXJsXTogICAgJ1lvdSBjYW5ub3Qgc3BlY2lmeSByZWxhdGl2ZSBsb2dpbiBwYWdlIFVSTHMgaW4gdGhlIFJvbGUgY29uc3RydWN0b3IuIFVzZSBhbiBhYnNvbHV0ZSBVUkwuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudHlwZVNjcmlwdENvbXBpbGVyTG9hZGluZ0Vycm9yXTogICAgJ1VuYWJsZSB0byBsb2FkIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyLlxcbntvcmlnaW5FcnJvck1lc3NhZ2V9LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEN1c3RvbWl6ZVNwZWNpZmllZENvbXBpbGVyc106ICdZb3UgY2Fubm90IHNwZWNpZnkgb3B0aW9ucyBmb3IgdGhlIHtub25jdXN0b21pemFibGVDb21waWxlckxpc3R9IGNvbXBpbGVye3N1ZmZpeH0uJyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RFbmFibGVSZXRyeVRlc3RQYWdlc09wdGlvbl06XG4gICAgICAgICdDYW5ub3QgZW5hYmxlIHRoZSBcXCdyZXRyeVRlc3RQYWdlc1xcJyBvcHRpb24uIEFwcGx5IG9uZSBvZiB0aGUgZm9sbG93aW5nIHR3byBzb2x1dGlvbnM6XFxuJyArXG4gICAgICAgICctLSBzZXQgXFwnbG9jYWxob3N0XFwnIGFzIHRoZSB2YWx1ZSBvZiB0aGUgXFwnaG9zdG5hbWVcXCcgb3B0aW9uXFxuJyArXG4gICAgICAgICctLSBydW4gVGVzdENhZmUgb3ZlciBIVFRQU1xcbicsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3NlckNvbm5lY3Rpb25FcnJvcl06ICAgICAgICAgICAgICAgJ3tvcmlnaW5FcnJvck1lc3NhZ2V9XFxue251bU9mTm90T3BlbmVkQ29ubmVjdGlvbn0gb2Yge251bU9mQWxsQ29ubmVjdGlvbnN9IGJyb3dzZXIgY29ubmVjdGlvbnMgaGF2ZSBub3QgYmVlbiBlc3RhYmxpc2hlZDpcXG57bGlzdE9mTm90T3BlbmVkQ29ubmVjdGlvbnN9XFxuXFxuSGludHM6XFxue2xpc3RPZkhpbnRzfScsXG4gICAgW0Jyb3dzZXJDb25uZWN0aW9uRXJyb3JIaW50LlRvb0hpZ2hDb25jdXJyZW5jeUZhY3Rvcl06ICdUaGUgZXJyb3IgY2FuIGJlIGR1ZSB0byBhIGNvbmN1cnJlbmN5IGZhY3RvciB0aGF0IGlzIHRvbyBoaWdoIGZvciB0aGUgaG9zdCBtYWNoaW5l4oCZcyBwZXJmb3JtYW5jZSAodGhlIGZhY3RvciB2YWx1ZSB7Y29uY3VycmVuY3lGYWN0b3J9IHdhcyBzcGVjaWZpZWQpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RyeSB0byBkZWNyZWFzZSB0aGUgY29uY3VycmVuY3kgZmFjdG9yIG9yIGVuc3VyZSBtb3JlIHN5c3RlbSByZXNvdXJjZXMgYXJlIGF2YWlsYWJsZSBvbiB0aGUgaG9zdCBtYWNoaW5lLicsXG4gICAgW0Jyb3dzZXJDb25uZWN0aW9uRXJyb3JIaW50LlVzZUJyb3dzZXJJbml0T3B0aW9uXTogJ1VzZSB0aGUgXCJicm93c2VySW5pdFRpbWVvdXRcIiBvcHRpb24gdG8gYWxsb3cgbW9yZSB0aW1lIGZvciB0aGUgYnJvd3NlciB0byBzdGFydC4gVGhlIHRpbWVvdXQgaXMgc2V0IHRvIHticm93c2VySW5pdFRpbWVvdXRNc2d9LicsXG4gICAgW0Jyb3dzZXJDb25uZWN0aW9uRXJyb3JIaW50LlJlc3RFcnJvckNhdXNlc106ICAgICAgJ1RoZSBlcnJvciBjYW4gYWxzbyBiZSBjYXVzZWQgYnkgbmV0d29yayBpc3N1ZXMgb3IgcmVtb3RlIGRldmljZSBmYWlsdXJlLiBNYWtlIHN1cmUgdGhhdCB0aGUgY29ubmVjdGlvbiBpcyBzdGFibGUgYW5kIHRoZSByZW1vdGUgZGV2aWNlIGNhbiBiZSByZWFjaGVkLidcbn07XG4iXX0=