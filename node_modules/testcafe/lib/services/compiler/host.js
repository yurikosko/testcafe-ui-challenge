"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const io_1 = require("./io");
const test_structure_1 = require("../serialization/test-structure");
const prepare_options_1 = __importDefault(require("../serialization/prepare-options"));
const test_run_tracker_1 = __importDefault(require("../../api/test-run-tracker"));
const proxy_1 = require("../utils/ipc/proxy");
const transport_1 = require("../utils/ipc/transport");
const async_event_emitter_1 = __importDefault(require("../../utils/async-event-emitter"));
const error_list_1 = __importDefault(require("../../errors/error-list"));
const SERVICE_PATH = require.resolve('./service');
class CompilerHost extends async_event_emitter_1.default {
    constructor() {
        super();
        this.runtime = Promise.resolve(void 0);
    }
    _setupRoutes(proxy) {
        proxy.register([
            this.executeAction,
            this.executeCommand,
            this.ready
        ], this);
    }
    async _init(runtime) {
        const resolvedRuntime = await runtime;
        if (resolvedRuntime)
            return resolvedRuntime;
        try {
            const service = child_process_1.spawn(process.argv0, [SERVICE_PATH], { stdio: [0, 1, 2, 'pipe', 'pipe', 'pipe'] });
            // HACK: Node.js definition are not correct when additional I/O channels are sp
            const stdio = service.stdio;
            const proxy = new proxy_1.IPCProxy(new transport_1.HostTransport(stdio[io_1.HOST_INPUT_FD], stdio[io_1.HOST_OUTPUT_FD], stdio[io_1.HOST_SYNC_FD]));
            this._setupRoutes(proxy);
            await this.once('ready');
            return { proxy, service };
        }
        catch (e) {
            return void 0;
        }
    }
    async _getRuntime() {
        const runtime = await this.runtime;
        if (!runtime)
            throw new Error();
        return runtime;
    }
    async init() {
        this.runtime = this._init(this.runtime);
        await this.runtime;
    }
    async stop() {
        const { service } = await this._getRuntime();
        service.kill();
    }
    _wrapTestFunction(id, functionName) {
        return async (testRun) => {
            try {
                return await this.runTest({ id, functionName, testRunId: testRun.id });
            }
            catch (err) {
                const errList = new error_list_1.default();
                errList.addError(err);
                throw errList;
            }
        };
    }
    async ready() {
        this.emit('ready');
    }
    async executeAction(data) {
        const targetTestRun = test_run_tracker_1.default.activeTestRuns[data.id];
        if (!targetTestRun)
            return void 0;
        return targetTestRun.executeAction(data.apiMethodName, data.command, data.callsite);
    }
    async executeCommand({ command, id }) {
        const targetTestRun = test_run_tracker_1.default.activeTestRuns[id];
        if (!targetTestRun)
            return void 0;
        return targetTestRun.executeCommand(command);
    }
    async getTests({ sourceList, compilerOptions }) {
        const { proxy } = await this._getRuntime();
        const units = await proxy.call(this.getTests, { sourceList, compilerOptions });
        return test_structure_1.restore(units, (...args) => this._wrapTestFunction(...args));
    }
    async runTest({ id, functionName, testRunId }) {
        const { proxy } = await this._getRuntime();
        return await proxy.call(this.runTest, { id, functionName, testRunId });
    }
    async cleanUp() {
        const { proxy } = await this._getRuntime();
        await proxy.call(this.cleanUp);
    }
    async setOptions({ value }) {
        const { proxy } = await this._getRuntime();
        const preparedOptions = prepare_options_1.default(value);
        await proxy.call(this.setOptions, { value: preparedOptions });
    }
}
exports.default = CompilerHost;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG9zdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9jb21waWxlci9ob3N0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaURBQW9EO0FBQ3BELDZCQUljO0FBRWQsb0VBQWtGO0FBQ2xGLHVGQUE4RDtBQUM5RCxrRkFBZ0Y7QUFDaEYsOENBQThDO0FBQzlDLHNEQUF1RDtBQUN2RCwwRkFBMkQ7QUFDM0QseUVBQXdEO0FBY3hELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFXbEQsTUFBcUIsWUFBYSxTQUFRLDZCQUFZO0lBR2xEO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFFUixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRU8sWUFBWSxDQUFFLEtBQWU7UUFDakMsS0FBSyxDQUFDLFFBQVEsQ0FBQztZQUNYLElBQUksQ0FBQyxhQUFhO1lBQ2xCLElBQUksQ0FBQyxjQUFjO1lBQ25CLElBQUksQ0FBQyxLQUFLO1NBQ2IsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNiLENBQUM7SUFFTyxLQUFLLENBQUMsS0FBSyxDQUFFLE9BQTRDO1FBQzdELE1BQU0sZUFBZSxHQUFHLE1BQU0sT0FBTyxDQUFDO1FBRXRDLElBQUksZUFBZTtZQUNmLE9BQU8sZUFBZSxDQUFDO1FBRTNCLElBQUk7WUFDQSxNQUFNLE9BQU8sR0FBRyxxQkFBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRW5HLCtFQUErRTtZQUMvRSxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBWSxD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QUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO1FBRS9FLE9BQU8sd0JBQW9CLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVNLEtBQUssQ0FBQyxPQUFPLENBQUUsRUFBRSxFQUFFLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBb0I7UUFDbkUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRTNDLE9BQU8sTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVNLEtBQUssQ0FBQyxPQUFPO1FBQ2hCLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUUzQyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFTSxLQUFLLENBQUMsVUFBVSxDQUFFLEVBQUUsS0FBSyxFQUF1QjtRQUNuRCxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFM0MsTUFBTSxlQUFlLEdBQUcseUJBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU5QyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7Q0FDSjtBQTlIRCwrQkE4SEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzcGF3biwgQ2hpbGRQcm9jZXNzIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQge1xuICAgIEhPU1RfSU5QVVRfRkQsXG4gICAgSE9TVF9PVVRQVVRfRkQsXG4gICAgSE9TVF9TWU5DX0ZEXG59IGZyb20gJy4vaW8nO1xuXG5pbXBvcnQgeyByZXN0b3JlIGFzIHJlc3RvcmVUZXN0U3RydWN0dXJlIH0gZnJvbSAnLi4vc2VyaWFsaXphdGlvbi90ZXN0LXN0cnVjdHVyZSc7XG5pbXBvcnQgcHJlcGFyZU9wdGlvbnMgZnJvbSAnLi4vc2VyaWFsaXphdGlvbi9wcmVwYXJlLW9wdGlvbnMnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyB0ZXN0UnVuVHJhY2tlciwgVGVzdFJ1biB9IGZyb20gJy4uLy4uL2FwaS90ZXN0LXJ1bi10cmFja2VyJztcbmltcG9ydCB7IElQQ1Byb3h5IH0gZnJvbSAnLi4vdXRpbHMvaXBjL3Byb3h5JztcbmltcG9ydCB7IEhvc3RUcmFuc3BvcnQgfSBmcm9tICcuLi91dGlscy9pcGMvdHJhbnNwb3J0JztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vLi4vdXRpbHMvYXN5bmMtZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgVGVzdENhZmVFcnJvckxpc3QgZnJvbSAnLi4vLi4vZXJyb3JzL2Vycm9yLWxpc3QnO1xuXG5pbXBvcnQge1xuICAgIENvbXBpbGVyUHJvdG9jb2wsXG4gICAgUnVuVGVzdEFyZ3VtZW50cyxcbiAgICBFeGVjdXRlQWN0aW9uQXJndW1lbnRzLFxuICAgIEZ1bmN0aW9uUHJvcGVydGllcyxcbiAgICBTZXRPcHRpb25zQXJndW1lbnRzLFxuICAgIEV4ZWN1dGVDb21tYW5kQXJndW1lbnRzXG59IGZyb20gJy4vcHJvdG9jb2wnO1xuXG5pbXBvcnQgeyBDb21waWxlckFyZ3VtZW50cyB9IGZyb20gJy4uLy4uL2NvbXBpbGVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IFRlc3QgZnJvbSAnLi4vLi4vYXBpL3N0cnVjdHVyZS90ZXN0JztcblxuY29uc3QgU0VSVklDRV9QQVRIID0gcmVxdWlyZS5yZXNvbHZlKCcuL3NlcnZpY2UnKTtcblxuaW50ZXJmYWNlIFJ1bnRpbWVSZXNvdXJjZXMge1xuICAgIHNlcnZpY2U6IENoaWxkUHJvY2VzcztcbiAgICBwcm94eTogSVBDUHJveHk7XG59XG5cbmludGVyZmFjZSBUZXN0RnVuY3Rpb24ge1xuICAgICh0ZXN0UnVuOiBUZXN0UnVuKTogUHJvbWlzZTx1bmtub3duPjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcGlsZXJIb3N0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIGltcGxlbWVudHMgQ29tcGlsZXJQcm90b2NvbCB7XG4gICAgcHJpdmF0ZSBydW50aW1lOiBQcm9taXNlPFJ1bnRpbWVSZXNvdXJjZXN8dW5kZWZpbmVkPjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5ydW50aW1lID0gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2V0dXBSb3V0ZXMgKHByb3h5OiBJUENQcm94eSk6IHZvaWQge1xuICAgICAgICBwcm94eS5yZWdpc3RlcihbXG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb24sXG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVDb21tYW5kLFxuICAgICAgICAgICAgdGhpcy5yZWFkeVxuICAgICAgICBdLCB0aGlzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9pbml0IChydW50aW1lOiBQcm9taXNlPFJ1bnRpbWVSZXNvdXJjZXN8dW5kZWZpbmVkPik6IFByb21pc2U8UnVudGltZVJlc291cmNlc3x1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRSdW50aW1lID0gYXdhaXQgcnVudGltZTtcblxuICAgICAgICBpZiAocmVzb2x2ZWRSdW50aW1lKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkUnVudGltZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHNwYXduKHByb2Nlc3MuYXJndjAsIFtTRVJWSUNFX1BBVEhdLCB7IHN0ZGlvOiBbMCwgMSwgMiwgJ3BpcGUnLCAncGlwZScsICdwaXBlJ10gfSk7XG5cbiAgICAgICAgICAgIC8vIEhBQ0s6IE5vZGUuanMgZGVmaW5pdGlvbiBhcmUgbm90IGNvcnJlY3Qgd2hlbiBhZGRpdGlvbmFsIEkvTyBjaGFubmVscyBhcmUgc3BcbiAgICAgICAgICAgIGNvbnN0IHN0ZGlvID0gc2VydmljZS5zdGRpbyBhcyBhbnk7XG4gICAgICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBJUENQcm94eShuZXcgSG9zdFRyYW5zcG9ydChzdGRpb1tIT1NUX0lOUFVUX0ZEXSwgc3RkaW9bSE9TVF9PVVRQVVRfRkRdLCBzdGRpb1tIT1NUX1NZTkNfRkRdKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3NldHVwUm91dGVzKHByb3h5KTtcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5vbmNlKCdyZWFkeScpO1xuXG4gICAgICAgICAgICByZXR1cm4geyBwcm94eSwgc2VydmljZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZ2V0UnVudGltZSAoKTogUHJvbWlzZTxSdW50aW1lUmVzb3VyY2VzPiB7XG4gICAgICAgIGNvbnN0IHJ1bnRpbWUgPSBhd2FpdCB0aGlzLnJ1bnRpbWU7XG5cbiAgICAgICAgaWYgKCFydW50aW1lKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG5cbiAgICAgICAgcmV0dXJuIHJ1bnRpbWU7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGluaXQgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSB0aGlzLl9pbml0KHRoaXMucnVudGltZSk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5ydW50aW1lO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzdG9wICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBzZXJ2aWNlIH0gPSBhd2FpdCB0aGlzLl9nZXRSdW50aW1lKCk7XG5cbiAgICAgICAgc2VydmljZS5raWxsKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfd3JhcFRlc3RGdW5jdGlvbiAoaWQ6IHN0cmluZywgZnVuY3Rpb25OYW1lOiBGdW5jdGlvblByb3BlcnRpZXMpOiBUZXN0RnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gYXN5bmMgdGVzdFJ1biA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJ1blRlc3QoeyBpZCwgZnVuY3Rpb25OYW1lLCB0ZXN0UnVuSWQ6IHRlc3RSdW4uaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTGlzdCA9IG5ldyBUZXN0Q2FmZUVycm9yTGlzdCgpO1xuXG4gICAgICAgICAgICAgICAgZXJyTGlzdC5hZGRFcnJvcihlcnIpO1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcmVhZHkgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGV4ZWN1dGVBY3Rpb24gKGRhdGE6IEV4ZWN1dGVBY3Rpb25Bcmd1bWVudHMpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0VGVzdFJ1biA9IHRlc3RSdW5UcmFja2VyLmFjdGl2ZVRlc3RSdW5zW2RhdGEuaWRdO1xuXG4gICAgICAgIGlmICghdGFyZ2V0VGVzdFJ1bilcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFRlc3RSdW4uZXhlY3V0ZUFjdGlvbihkYXRhLmFwaU1ldGhvZE5hbWUsIGRhdGEuY29tbWFuZCwgZGF0YS5jYWxsc2l0ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGV4ZWN1dGVDb21tYW5kICh7IGNvbW1hbmQsIGlkIH06IEV4ZWN1dGVDb21tYW5kQXJndW1lbnRzKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgICAgIGNvbnN0IHRhcmdldFRlc3RSdW4gPSB0ZXN0UnVuVHJhY2tlci5hY3RpdmVUZXN0UnVuc1tpZF07XG5cbiAgICAgICAgaWYgKCF0YXJnZXRUZXN0UnVuKVxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0VGVzdFJ1bi5leGVjdXRlQ29tbWFuZChjb21tYW5kKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VGVzdHMgKHsgc291cmNlTGlzdCwgY29tcGlsZXJPcHRpb25zIH06IENvbXBpbGVyQXJndW1lbnRzKTogUHJvbWlzZTxUZXN0W10+IHtcbiAgICAgICAgY29uc3QgeyBwcm94eSB9ID0gYXdhaXQgdGhpcy5fZ2V0UnVudGltZSgpO1xuXG4gICAgICAgIGNvbnN0IHVuaXRzID0gYXdhaXQgcHJveHkuY2FsbCh0aGlzLmdldFRlc3RzLCB7IHNvdXJjZUxpc3QsIGNvbXBpbGVyT3B0aW9ucyB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdG9yZVRlc3RTdHJ1Y3R1cmUodW5pdHMsICguLi5hcmdzKSA9PiB0aGlzLl93cmFwVGVzdEZ1bmN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcnVuVGVzdCAoeyBpZCwgZnVuY3Rpb25OYW1lLCB0ZXN0UnVuSWQgfTogUnVuVGVzdEFyZ3VtZW50cyk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAgICBjb25zdCB7IHByb3h5IH0gPSBhd2FpdCB0aGlzLl9nZXRSdW50aW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3h5LmNhbGwodGhpcy5ydW5UZXN0LCB7IGlkLCBmdW5jdGlvbk5hbWUsIHRlc3RSdW5JZCB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgY2xlYW5VcCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgcHJveHkgfSA9IGF3YWl0IHRoaXMuX2dldFJ1bnRpbWUoKTtcblxuICAgICAgICBhd2FpdCBwcm94eS5jYWxsKHRoaXMuY2xlYW5VcCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNldE9wdGlvbnMgKHsgdmFsdWUgfTogU2V0T3B0aW9uc0FyZ3VtZW50cyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB7IHByb3h5IH0gPSBhd2FpdCB0aGlzLl9nZXRSdW50aW1lKCk7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWRPcHRpb25zID0gcHJlcGFyZU9wdGlvbnModmFsdWUpO1xuXG4gICAgICAgIGF3YWl0IHByb3h5LmNhbGwodGhpcy5zZXRPcHRpb25zLCB7IHZhbHVlOiBwcmVwYXJlZE9wdGlvbnMgfSk7XG4gICAgfVxufVxuIl19