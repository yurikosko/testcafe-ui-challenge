"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const names_1 = __importDefault(require("../session/events/names"));
const state_snapshot_1 = __importDefault(require("./state-snapshot"));
const mustache_1 = __importDefault(require("mustache"));
const read_file_relative_1 = require("read-file-relative");
const events_1 = require("events");
const url_1 = require("url");
const cookies_1 = __importDefault(require("./cookies"));
const storage_1 = __importDefault(require("../upload/storage"));
const command_1 = __importDefault(require("./command"));
const generate_unique_id_1 = __importDefault(require("../utils/generate-unique-id"));
const service_routes_1 = __importDefault(require("../proxy/service-routes"));
const default_request_timeout_1 = __importDefault(require("../request-pipeline/destination-request/default-request-timeout"));
const json_1 = require("../utils/json");
const TASK_TEMPLATE = read_file_relative_1.readSync('../client/task.js.mustache');
class Session extends events_1.EventEmitter {
    constructor(uploadRoots, options) {
        super();
        this.id = generate_unique_id_1.default();
        this.cookies = new cookies_1.default();
        this.proxy = null;
        this.externalProxySettings = null;
        this.pageLoadCount = 0;
        this.pendingStateSnapshot = null;
        this.injectable = { scripts: ['/hammerhead.js'], styles: [], userScripts: [] };
        this.requestEventListeners = new Map();
        this.mocks = new Map();
        this._recordMode = false;
        this.uploadStorage = new storage_1.default(uploadRoots);
        this.options = this._getOptions(options);
    }
    _getOptions(options = {}) {
        const requestTimeout = {
            page: options.requestTimeout && options.requestTimeout.page || default_request_timeout_1.default.page,
            ajax: options.requestTimeout && options.requestTimeout.ajax || default_request_timeout_1.default.ajax,
        };
        delete options.requestTimeout;
        return Object.assign({
            disablePageCaching: false,
            allowMultipleWindows: false,
            windowId: '',
            requestTimeout
        }, options);
    }
    // State
    getStateSnapshot() {
        return new state_snapshot_1.default(this.cookies.serializeJar(), null);
    }
    useStateSnapshot(snapshot) {
        if (!snapshot)
            throw new Error('"snapshot" parameter cannot be null. Use StateSnapshot.empty() instead of it.');
        // NOTE: we don't perform state switch immediately, since there might be
        // pending requests from current page. Therefore, we perform switch in
        // onPageRequest handler when new page is requested.
        this.pendingStateSnapshot = snapshot;
    }
    async handleServiceMessage(msg, serverInfo) {
        if (this[msg.cmd])
            return await this[msg.cmd](msg, serverInfo);
        throw new Error('Malformed service message or message handler is not implemented');
    }
    _fillTaskScriptTemplate({ serverInfo, isFirstPageLoad, referer, cookie, iframeTaskScriptTemplate, payloadScript, allowMultipleWindows, isRecordMode, windowId }) {
        referer = referer && json_1.stringify(referer) || '{{{referer}}}';
        cookie = cookie || '{{{cookie}}}';
        iframeTaskScriptTemplate = iframeTaskScriptTemplate || '{{{iframeTaskScriptTemplate}}}';
        const { domain, crossDomainPort } = serverInfo;
        return mustache_1.default.render(TASK_TEMPLATE, {
            sessionId: this.id,
            serviceMsgUrl: domain + service_routes_1.default.messaging,
            transportWorkerUrl: domain + service_routes_1.default.transportWorker,
            forceProxySrcForImage: this.hasRequestEventListeners(),
            crossDomainPort,
            isFirstPageLoad,
            referer,
            cookie,
            iframeTaskScriptTemplate,
            payloadScript,
            allowMultipleWindows,
            isRecordMode,
            windowId: windowId || ''
        });
    }
    async getIframeTaskScriptTemplate(serverInfo) {
        const taskScriptTemplate = this._fillTaskScriptTemplate({
            serverInfo,
            isFirstPageLoad: false,
            referer: null,
            cookie: null,
            iframeTaskScriptTemplate: null,
            payloadScript: await this.getIframePayloadScript(true),
            allowMultipleWindows: this.options.allowMultipleWindows,
            isRecordMode: this._recordMode
        });
        return json_1.stringify(taskScriptTemplate);
    }
    async getTaskScript({ referer, cookieUrl, serverInfo, isIframe, withPayload, windowId }) {
        const cookies = json_1.stringify(this.cookies.getClientString(cookieUrl));
        let payloadScript = '';
        if (withPayload)
            payloadScript = isIframe ? await this.getIframePayloadScript(false) : await this.getPayloadScript();
        const taskScript = this._fillTaskScriptTemplate({
            serverInfo,
            isFirstPageLoad: this.pageLoadCount === 0,
            referer,
            cookie: cookies,
            iframeTaskScriptTemplate: await this.getIframeTaskScriptTemplate(serverInfo),
            payloadScript,
            allowMultipleWindows: this.options.allowMultipleWindows,
            isRecordMode: this._recordMode,
            windowId
        });
        this.pageLoadCount++;
        return taskScript;
    }
    setExternalProxySettings(proxySettings) {
        if (typeof proxySettings === 'string')
            proxySettings = { url: proxySettings };
        if (!proxySettings || !proxySettings.url)
            return;
        const { url, bypassRules } = proxySettings;
        const parsedUrl = url_1.parse('http://' + url);
        let settings = null;
        if (parsedUrl && parsedUrl.host) {
            settings = {
                host: parsedUrl.host,
                hostname: parsedUrl.hostname
            };
            if (bypassRules)
                settings.bypassRules = bypassRules;
            if (parsedUrl.port)
                settings.port = parsedUrl.port;
            if (parsedUrl.auth) {
                settings.proxyAuth = parsedUrl.auth;
                settings.authHeader = 'Basic ' + Buffer.from(parsedUrl.auth).toString('base64');
            }
        }
        this.externalProxySettings = settings;
    }
    onPageRequest(ctx) {
        if (!this.pendingStateSnapshot)
            return;
        this.cookies.setJar(this.pendingStateSnapshot.cookies);
        ctx.restoringStorages = this.pendingStateSnapshot.storages;
        this.pendingStateSnapshot = null;
    }
    // Request hooks
    hasRequestEventListeners() {
        return !!this.requestEventListeners.size;
    }
    addRequestEventListeners(requestFilterRule, listeners, errorHandler) {
        const listenersData = {
            listeners,
            errorHandler
        };
        this.requestEventListeners.set(requestFilterRule, listenersData);
    }
    removeRequestEventListeners(requestFilterRule) {
        this.requestEventListeners.delete(requestFilterRule);
    }
    clearRequestEventListeners() {
        this.requestEventListeners.clear();
    }
    async getRequestFilterRules(requestInfo) {
        const rulesArray = Array.from(this.requestEventListeners.keys());
        const matchedRules = await Promise.all(rulesArray.map(async (rule) => {
            if (await rule.match(requestInfo))
                return rule;
            return void 0;
        }));
        return matchedRules.filter(rule => !!rule);
    }
    async callRequestEventCallback(eventName, requestFilterRule, eventData) {
        const requestEventListenersData = this.requestEventListeners.get(requestFilterRule);
        if (!requestEventListenersData)
            return;
        const { listeners, errorHandler } = requestEventListenersData;
        const targetRequestEventCallback = listeners[eventName];
        if (typeof targetRequestEventCallback !== 'function')
            return;
        try {
            await targetRequestEventCallback(eventData);
        }
        catch (e) {
            if (typeof errorHandler !== 'function')
                return;
            const event = {
                error: e,
                methodName: eventName
            };
            errorHandler(event);
        }
    }
    setMock(requestFilterRule, mock) {
        this.mocks.set(requestFilterRule, mock);
    }
    getMock(requestFilterRule) {
        return this.mocks.get(requestFilterRule);
    }
    setRecordMode() {
        this._recordMode = true;
    }
    // Service message handlers
    async [command_1.default.uploadFiles](msg) {
        return await this.uploadStorage.store(msg.fileNames, msg.data);
    }
    async [command_1.default.getUploadedFiles](msg) {
        return await this.uploadStorage.get(msg.filePaths);
    }
}
exports.default = Session;module.exports = exports.default;

